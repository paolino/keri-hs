{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"keri-hs","text":"<p>A learning-oriented Haskell implementation of KERI (Key Event Receipt Infrastructure), the decentralized identity protocol based on self-certifying identifiers and append-only key event logs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Ed25519 cryptography via <code>crypton</code></li> <li>CESR encoding/decoding (Composable Event Streaming Representation)</li> <li>KERI event types: inception, rotation, interaction, receipt</li> <li>Key state machine with pre-rotation commitment</li> <li>Key Event Log management with append verification and replay</li> <li>CLI for key management (<code>init</code>, <code>sign</code>, <code>show</code>, <code>export</code>)</li> <li>TCP demo for two-party direct-mode KEL exchange</li> </ul>"},{"location":"#quick-start","title":"Quick start","text":"<pre><code># Run with nix\nnix run github:paolino/keri-hs#keri-cli -- init\nnix run github:paolino/keri-hs#keri-cli -- show\n\n# Or build locally\nnix develop -c cabal run keri-cli -- init\n</code></pre>"},{"location":"#scope","title":"Scope","text":"<p>This is a learning-oriented implementation covering:</p> <ul> <li>Ed25519 only (no secp256k1)</li> <li>Blake2b-256 digests (no Blake3/SHA3)</li> <li>Simple integer thresholds (no fractional weights)</li> <li>Direct mode only (no witnesses, no delegation)</li> </ul>"},{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#module-structure","title":"Module structure","text":"<pre><code>graph TD\n    subgraph CESR\n        DC[DerivationCode] --&gt; P[Primitive]\n        P --&gt; Enc[Encode]\n        P --&gt; Dec[Decode]\n    end\n\n    subgraph Crypto\n        Ed[Ed25519] --&gt; Dig[Digest]\n        B3[Blake3] --&gt; Dig\n    end\n\n    subgraph Events\n        EV[Event] --&gt; Icp[Inception]\n        EV --&gt; Rot[Rotation]\n        EV --&gt; Ixn[Interaction]\n        EV --&gt; Rct[Receipt]\n        EV --&gt; Ser[Serialize]\n        Ver[Version] --&gt; Ser\n    end\n\n    subgraph \"Key State\"\n        KS[KeyState] --&gt; PR[PreRotation]\n        KS --&gt; Vfy[Verify]\n    end\n\n    subgraph KEL\n        K[Kel] --&gt; App[Append]\n        K --&gt; Rep[Replay]\n    end\n\n    Enc --&gt; Dig\n    Dec --&gt; Vfy\n    Ser --&gt; Dig\n    KS --&gt; App\n    KS --&gt; Rep\n    Vfy --&gt; App</code></pre>"},{"location":"architecture/#module-list","title":"Module list","text":"Module Description <code>Keri.Cesr.DerivationCode</code> CESR code table: <code>D</code> (Ed25519 key), <code>F</code> (Blake2b-256 digest), <code>0B</code> (signature) <code>Keri.Cesr.Primitive</code> Qualified primitive: derivation code + raw bytes <code>Keri.Cesr.Encode</code> Primitive to base64url text <code>Keri.Cesr.Decode</code> Base64url text to primitive <code>Keri.Crypto.Ed25519</code> Key generation, signing, verification via <code>crypton</code> <code>Keri.Crypto.Blake3</code> Blake2b-256 hashing (stand-in for Blake3) <code>Keri.Crypto.Digest</code> SAID (Self-Addressing Identifier) computation <code>Keri.Event</code> Event sum type and data records <code>Keri.Event.Inception</code> Inception event construction with SAID <code>Keri.Event.Rotation</code> Key rotation event <code>Keri.Event.Interaction</code> Non-key-change interaction event <code>Keri.Event.Receipt</code> Direct-mode receipt <code>Keri.Event.Serialize</code> Deterministic JSON via ordered <code>pairs</code> <code>Keri.Event.Version</code> Version string: <code>KERI10JSON{size:06x}_</code> <code>Keri.KeyState</code> Key state record and <code>applyEvent</code> state machine <code>Keri.KeyState.PreRotation</code> Pre-rotation key commitment via Blake2b-256 digest <code>Keri.KeyState.Verify</code> Indexed signature verification against threshold <code>Keri.Kel</code> KEL and SignedEvent types <code>Keri.Kel.Append</code> Append with signature and chain verification <code>Keri.Kel.Replay</code> Replay KEL to derive current key state"},{"location":"architecture/#key-design-decisions","title":"Key design decisions","text":"<ul> <li>Deterministic JSON: <code>Data.Aeson.Encoding.pairs</code> with explicit field ordering (not HashMap)</li> <li>SAID: Serialize with 44-char <code>#</code> placeholder in <code>\"d\"</code> field, hash, replace. For inception: <code>\"i\"</code> = <code>\"d\"</code> (self-addressing)</li> <li>Pre-rotation: Each next-key commitment = <code>blake2b_256(publicKeyBytes)</code>, CESR-encoded as digest</li> <li>Version string: Fixed 6-hex-digit size field avoids the chicken-and-egg sizing problem</li> <li>Indexed signatures: <code>[(Int, Text)]</code> where index maps to position in the key list</li> </ul>"},{"location":"cli/","title":"CLI Reference","text":"<p>The <code>keri-cli</code> executable provides key management for KERI identifiers.</p>"},{"location":"cli/#installation","title":"Installation","text":"<pre><code>nix run github:paolino/keri-hs#keri-cli -- &lt;command&gt;\n</code></pre> <p>Or build from source:</p> <pre><code>nix develop -c cabal build keri-cli\n</code></pre>"},{"location":"cli/#commands","title":"Commands","text":""},{"location":"cli/#init","title":"<code>init</code>","text":"<p>Create a new KERI identifier with an Ed25519 key pair.</p> <pre><code>keri-cli init\n# Initialized: EaBc...XyZ\n</code></pre> <p>This generates:</p> <ul> <li>A signing key pair (current)</li> <li>A pre-rotated next key pair</li> <li>An inception event with SAID as the self-addressing identifier</li> </ul> <p>Storage layout:</p> <pre><code>~/.keri/\n  current           # text file with current prefix\n  &lt;prefix&gt;/\n    kel.ndjson      # newline-delimited event JSON\n    secret.key      # base64url-encoded Ed25519 secret key\n</code></pre>"},{"location":"cli/#sign","title":"<code>sign</code>","text":"<p>Sign a message with the current identifier's key.</p> <pre><code>keri-cli sign \"hello world\"\n# 0BAe...signature...\n</code></pre> <p>The output is a CESR-encoded Ed25519 signature (code <code>0B</code>, 88 characters).</p>"},{"location":"cli/#show","title":"<code>show</code>","text":"<p>Display the current identifier state.</p> <pre><code>keri-cli show\n# Events: 1\n# Prefix: EaBc...XyZ\n# Last digest: EaBc...XyZ\n</code></pre> <p>Shows the number of events in the KEL, the identifier prefix, and the most recent event digest.</p>"},{"location":"cli/#export","title":"<code>export</code>","text":"<p>Export the full Key Event Log as newline-delimited JSON.</p> <pre><code>keri-cli export\n# {\"v\":\"KERI10JSON0001ab_\",\"t\":\"icp\",\"d\":\"EaBc...\",\"i\":\"EaBc...\", ...}\n</code></pre> <p>Each line is a serialized KERI event in canonical JSON format with deterministic field ordering.</p>"},{"location":"cli/#storage","title":"Storage","text":"<p>All data is stored under <code>~/.keri/</code>:</p> File Format Contents <code>current</code> UTF-8 text Active identifier prefix <code>&lt;prefix&gt;/kel.ndjson</code> NDJSON Key Event Log <code>&lt;prefix&gt;/secret.key</code> Base64url Ed25519 secret key (32 bytes)"},{"location":"cli/#cesr-output-format","title":"CESR output format","text":"<p>Signatures and identifiers use CESR (Composable Event Streaming Representation) encoding:</p> Code Type Length <code>D</code> Ed25519 public key 44 chars <code>F</code> Blake2b-256 digest 44 chars <code>0B</code> Ed25519 signature 88 chars"},{"location":"keri-protocol/","title":"KERI Protocol: A Deep Introduction","text":"<p>Key Event Receipt Infrastructure \u2014 a decentralized identity protocol built on cryptographic autonomy, portability, and verifiability without dependence on any ledger or registry.</p>"},{"location":"keri-protocol/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Motivation and Design Philosophy</li> <li>Core Concepts</li> <li>Key Event Log (KEL)</li> <li>Event Types</li> <li>Key Management and Rotation</li> <li>Witnesses and Watchers</li> <li>Delegation</li> <li>Duplicity Detection and the KERI Security Model</li> <li>Trust Hierarchy Without a Ledger</li> <li>KERI vs Other DID Methods</li> <li>ACDC: Authentic Chained Data Containers</li> <li>Implementation Landscape</li> <li>Strengths and Tradeoffs</li> <li>Quick Reference Glossary</li> </ol>"},{"location":"keri-protocol/#1-motivation-and-design-philosophy","title":"1. Motivation and Design Philosophy","text":"<p>KERI was created by Samuel M. Smith (Ph.D.) and first published in a 2019 white paper. The fundamental problem it addresses is: how can an entity control its own cryptographic identifier without depending on any external registry, blockchain, or certificate authority?</p> <p>Traditional PKI ties identity to a CA-signed certificate. Blockchain-based DID methods (did:ethr, did:ion, etc.) tie identity to a specific ledger. Both approaches introduce infrastructure dependency \u2014 the identity is only as portable and available as the underlying infrastructure allows.</p> <p>KERI's design principles are:</p> <ul> <li>Self-certifying identifiers (SCIs): the identifier itself is derived from the public key, so no external authority is needed to bind key to identity.</li> <li>Cryptographic autonomy: the controller always retains the ability to prove control through private key possession.</li> <li>Portability: a KERI identifier and its Key Event Log can be replicated anywhere; no single infrastructure point of failure.</li> <li>Minimal sufficient means: avoid complexity; use only what is necessary to achieve security goals.</li> <li>End-verifiability: any verifier can independently validate the entire history of an identifier by replaying the Key Event Log.</li> </ul> <p>KERI is not a blockchain, not a DID method (though it can be expressed as one: <code>did:keri</code>), and not a credential format \u2014 it is a foundational identity layer upon which all of these can be built.</p>"},{"location":"keri-protocol/#2-core-concepts","title":"2. Core Concepts","text":""},{"location":"keri-protocol/#21-autonomic-identifier-aid","title":"2.1 Autonomic Identifier (AID)","text":"<p>An Autonomic Identifier (AID) is a self-certifying identifier. It is derived directly from a public key (or a commitment to a set of keys in the multisig case):</p> <pre><code>AID = Base64URL( Blake3( public_key ) )   # simplified\n</code></pre> <p>More precisely, the AID is derived from the inception key digest \u2014 a cryptographic hash of the initial controlling public key(s). This creates a permanent, unforgeable binding between the identifier and its controlling key material at inception.</p> <p>No registry, DNS, or blockchain is consulted to verify this binding. The math alone is sufficient.</p> <pre><code>flowchart TD\n    K1[\"Inception Key Pair\\npub_key_0, priv_key_0\"]\n    H[\"Hash(pub_key_0)\\nBlake3 / SHA3-256\"]\n    AID[\"AID Prefix\\nBase64URL(hash)\\ne.g. EKpNx3NqKFPSGF9...\"]\n    SIGN[\"Sign events with\\npriv_key_0\"]\n    VERIFY[\"Anyone can verify:\\nHash(pub_key_0) == AID prefix\\nNo CA needed\"]\n\n    K1 --&gt; H --&gt; AID\n    K1 --&gt; SIGN\n    AID --&gt; VERIFY</code></pre>"},{"location":"keri-protocol/#22-pre-rotation","title":"2.2 Pre-rotation","text":"<p>KERI's most important innovation is pre-rotation: at inception (and at each rotation), the controller commits to the digest of the next set of keys \u2014 before those keys are ever used or revealed.</p> <pre><code>Inception event:\n  keys:      [current_pub_key_1, ...]\n  next_keys: [hash(next_pub_key_1), ...]   &lt;- commitment, not the key itself\n</code></pre> <p>This has a profound security implication: even if an attacker compromises your current private key, they cannot perform a valid rotation because they do not know the pre-committed next key, and cannot forge a valid digest preimage.</p> <p>Pre-rotation elevates KERI's security model above traditional PKI and even most blockchain DID methods.</p>"},{"location":"keri-protocol/#23-establishment-vs-non-establishment-events","title":"2.3 Establishment vs Non-establishment Events","text":"<p>KERI distinguishes two classes of events:</p> Class Purpose Examples Establishment Change the key state <code>icp</code>, <code>rot</code>, <code>dip</code>, <code>drt</code> Non-establishment Anchor data / interact <code>ixn</code> <p>Only establishment events change the authoritative key set. Non-establishment events (interactions) allow the controller to anchor arbitrary data (e.g., credential issuances, service endpoint changes) without rotating keys.</p>"},{"location":"keri-protocol/#3-key-event-log-kel","title":"3. Key Event Log (KEL)","text":"<p>The Key Event Log (KEL) is the authoritative, append-only, cryptographically-chained log of all key management events for an AID. It is the single source of truth for the current key state of an identifier.</p> <p>Each event in the KEL:</p> <ol> <li>Contains a sequence number (<code>sn</code>)</li> <li>Contains the digest of the prior event (<code>p</code>) \u2014 creating a hash chain</li> <li>Is signed by the current authoritative key set</li> <li>May reference a digest of the next key set (pre-rotation commitment)</li> </ol> <pre><code>Event_n:\n  v:   version string\n  t:   event type (icp | rot | ixn | ...)\n  d:   SAID (self-addressing identifier = digest of this event)\n  i:   AID (identifier prefix)\n  sn:  sequence number\n  p:   digest of prior event\n  kt:  signing threshold\n  k:   list of current public keys\n  nt:  next key threshold\n  n:   list of next key digests (pre-rotation)\n  bt:  backer threshold\n  b:   list of backers (witnesses)\n  c:   config traits\n  a:   anchored data (for ixn events)\n</code></pre> <p>The SAID (Self-Addressing IDentifier) is the digest of the event itself, computed after substituting a placeholder for the <code>d</code> field. This gives every event a globally unique, self-certifying identifier.</p> <p>KEL hash chain \u2014 each event commits to the prior event's digest:</p> <pre><code>flowchart LR\n    icp[\"icp sn=0\\np: null\\nk: pub_key_0\\nn: H(next_key_0)\\nsigned: priv_key_0\"]\n    ixn[\"ixn sn=1\\np: SAID(icp)\\na: anchor_data\\nsigned: priv_key_0\"]\n    rot[\"rot sn=2\\np: SAID(ixn)\\nk: next_key_0 revealed\\nn: H(next_key_1)\\nsigned: next_priv_key_0\"]\n    ixn2[\"ixn sn=3\\np: SAID(rot)\\na: anchor_data\\nsigned: next_priv_key_0\"]\n\n    icp --&gt; ixn --&gt; rot --&gt; ixn2</code></pre>"},{"location":"keri-protocol/#kel-verification","title":"KEL Verification","text":"<p>To verify a KEL, a verifier:</p> <ol> <li>Validates the inception event: checks that the AID prefix matches the digest of the inception keys.</li> <li>For each subsequent event: checks the prior event digest, verifies signatures against the current key state, verifies threshold satisfaction.</li> <li>For each rotation: verifies that the new keys match the previously committed next key digests.</li> </ol> <p>This verification is fully end-to-end and requires no external oracle.</p>"},{"location":"keri-protocol/#4-event-types","title":"4. Event Types","text":""},{"location":"keri-protocol/#icp-inception","title":"<code>icp</code> \u2014 Inception","text":"<p>Creates the AID. Establishes the initial key set and the pre-rotation commitment to the next key set. The AID prefix is derived from this event.</p>"},{"location":"keri-protocol/#rot-rotation","title":"<code>rot</code> \u2014 Rotation","text":"<p>Rotates the key set. Must satisfy the signing threshold of the current key set AND reveal the pre-committed next keys. Establishes a new next-key commitment.</p>"},{"location":"keri-protocol/#ixn-interaction","title":"<code>ixn</code> \u2014 Interaction","text":"<p>A non-establishment event. Signed by the current key set. Used to anchor arbitrary data (credential hashes, service endpoint changes, etc.) into the KEL without rotating keys.</p>"},{"location":"keri-protocol/#dip-delegated-inception","title":"<code>dip</code> \u2014 Delegated Inception","text":"<p>Like <code>icp</code>, but for a delegated AID. The delegating AID must anchor a seal of this event in its own KEL, creating a two-way binding.</p>"},{"location":"keri-protocol/#drt-delegated-rotation","title":"<code>drt</code> \u2014 Delegated Rotation","text":"<p>Like <code>rot</code>, but for a delegated AID, requiring the delegator's co-signature.</p> <p>AID lifecycle state machine:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; Inception : icp event\n\n    Inception --&gt; Active : Witnesses receipt icp\n\n    Active --&gt; Active : ixn event\\nanchor data, no key change\n\n    Active --&gt; Rotated : rot event\\nnew keys revealed\\nnew pre-rotation committed\n\n    Rotated --&gt; Active : ixn event\\nusing new keys\n\n    Rotated --&gt; Rotated : rot event\\nrotate again\n\n    Active --&gt; Delegating : dip event\\ndelegate to child AID\n\n    Delegating --&gt; Active : delegation anchored\\nin delegator KEL\n\n    Active --&gt; [*] : rot with empty next keys\\ndeliberate abandonment</code></pre>"},{"location":"keri-protocol/#5-key-management-and-rotation","title":"5. Key Management and Rotation","text":""},{"location":"keri-protocol/#thresholds-and-multisig","title":"Thresholds and Multisig","text":"<p>KERI natively supports weighted threshold multisig. The signing threshold (<code>kt</code>) can be:</p> <ul> <li>A simple integer: <code>\"kt\": \"2\"</code> means 2-of-n</li> <li>A fractional weight list: <code>\"kt\": [\"1/2\", \"1/2\", \"1/4\"]</code> \u2014 more flexible M-of-N with weights</li> </ul> <p>This allows sophisticated key ceremonies: HSM keys, hardware security keys, geographically distributed keys, and organizational key hierarchies.</p>"},{"location":"keri-protocol/#key-compromise-recovery","title":"Key Compromise Recovery","text":"<p>With pre-rotation, recovery from a compromised current key is straightforward:</p> <ol> <li>The attacker has the current private key but not the next private key (which was never exposed).</li> <li>The controller uses the next key (whose digest was pre-committed) to sign a rotation event.</li> <li>The KEL is updated. The attacker's key is revoked.</li> <li>The controller commits to a new next key.</li> </ol> <p>Pre-rotation security: attacker cannot forge a rotation</p> <pre><code>sequenceDiagram\n    participant C as Controller\n    participant W as Witness Network\n    participant A as Attacker\n\n    Note over C: Inception\n    C-&gt;&gt;W: icp event, k=[pub0], n=[H(next0)]\n    Note over W: Receipts issued\n\n    Note over A: Attacker compromises priv0\n    A--&gt;&gt;W: Tries to rotate (does not know next0)\n    Note over W: REJECTED - cannot satisfy pre-rotation commitment\n\n    Note over C: Legitimate rotation\n    C-&gt;&gt;W: rot event, k=[next0] revealed, n=[H(next1)], signed by priv_next0\n    Note over W: Valid - next0 matches H(next0). Receipts issued.\n\n    Note over A: Has priv0 but next0 already rotated away\n    A--&gt;&gt;W: Stale key - too late</code></pre> <p>If both the current key and the next key are compromised simultaneously, recovery requires falling back to the witness network and potentially a social recovery process \u2014 KERI acknowledges this as a residual risk.</p>"},{"location":"keri-protocol/#partial-rotation","title":"Partial Rotation","text":"<p>KERI supports partial rotation: not all keys in a multisig set need to rotate simultaneously. This enables rolling key ceremonies without requiring all signers to be online at once.</p>"},{"location":"keri-protocol/#6-witnesses-and-watchers","title":"6. Witnesses and Watchers","text":""},{"location":"keri-protocol/#witnesses","title":"Witnesses","text":"<p>A witness is a service that receives, validates, and receipts key events. Witnesses:</p> <ul> <li>Maintain a copy of the controller's KEL</li> <li>Issue receipts: signed acknowledgments that they have seen and validated an event</li> <li>Provide availability and consistency guarantees</li> </ul> <p>The backer threshold (<code>bt</code>) specifies how many witness receipts are required before an event is considered sufficiently witnessed. This threshold is established at inception and can be updated at rotation.</p> <p>Witnesses do not control the identifier \u2014 they merely attest to having seen events. Their role is analogous to notaries or timestamping services, but cryptographically stronger.</p>"},{"location":"keri-protocol/#watchers","title":"Watchers","text":"<p>Watchers are verifier-side infrastructure. They monitor multiple KELs and detect duplicity (see below). Unlike witnesses (which are chosen by the controller), watchers are chosen by the verifier.</p> <p>This creates a two-sided trust model: controllers choose witnesses, verifiers choose watchers. Neither side can unilaterally subvert the system.</p> <pre><code>flowchart LR\n    subgraph Controller[\"Controller\"]\n        KEL[\"Key Event Log\"]\n    end\n\n    subgraph Witnesses[\"Witness Pool\\ncontroller-chosen\"]\n        W1[\"Witness 1\"]\n        W2[\"Witness 2\"]\n        W3[\"Witness 3\"]\n    end\n\n    subgraph Verifier[\"Verifier\"]\n        subgraph Watchers[\"Watcher Pool\\nverifier-chosen\"]\n            Wt1[\"Watcher A\"]\n            Wt2[\"Watcher B\"]\n        end\n        V[\"Verification Logic\"]\n    end\n\n    KEL --&gt; W1\n    KEL --&gt; W2\n    KEL --&gt; W3\n\n    W1 --&gt;|\"KEL + receipts\"| Wt1\n    W2 --&gt;|\"KEL + receipts\"| Wt1\n    W3 --&gt;|\"KEL + receipts\"| Wt2\n\n    Wt1 --&gt;|\"cross-check\"| V\n    Wt2 --&gt;|\"cross-check\"| V</code></pre>"},{"location":"keri-protocol/#7-delegation","title":"7. Delegation","text":"<p>KERI supports cryptographic delegation: an AID can delegate key management authority to another AID. This is the foundation for building organizational hierarchies and enterprise key management systems.</p> <p>A delegation relationship requires:</p> <ol> <li>The delegatee creates a <code>dip</code> (delegated inception) event.</li> <li>The delegator anchors a seal (hash reference) of the <code>dip</code> in its own KEL via an <code>ixn</code> or <code>rot</code> event.</li> <li>Both events must exist and be verifiable for the delegation to be valid.</li> </ol> <p>This mutual anchoring creates a bi-directional cryptographic binding. You cannot forge a delegation without compromising both the delegatee's keys and the delegator's keys simultaneously.</p> <pre><code>sequenceDiagram\n    participant DA as Delegatee\n    participant DR as Delegator\n    participant W as Witness Network\n\n    Note over DA: Step 1 - Delegatee creates dip\n    DA-&gt;&gt;W: dip event, i: delegatee_AID, di: delegator_AID\n\n    Note over DR: Step 2 - Delegator anchors seal\n    DR-&gt;&gt;W: ixn event, a: [seal of dip event]\n\n    Note over W: Both events receipted\n\n    Note over DA,DR: Delegation valid only when BOTH events exist</code></pre>"},{"location":"keri-protocol/#8-duplicity-detection-and-the-keri-security-model","title":"8. Duplicity Detection and the KERI Security Model","text":""},{"location":"keri-protocol/#the-duplicity-problem","title":"The Duplicity Problem","text":"<p>A malicious controller (or attacker) might try to present two different versions of a KEL to different parties. KERI addresses this through the watcher network and First Seen ordering.</p> <pre><code>flowchart TD\n    C[\"Controller equivocating\"]\n\n    C --&gt;|\"KEL version A at sn=3\"| W1[\"Witness 1\"]\n    C --&gt;|\"KEL version B at sn=3\"| W2[\"Witness 2\"]\n\n    W1 --&gt; Watcher\n    W2 --&gt; Watcher\n\n    Watcher{\"Watcher: sn=3 conflict!\"}\n\n    Watcher --&gt;|\"DUPLICITY DETECTED\"| Alert[\"Verifier flagged:\\nAID untrustworthy\"]</code></pre>"},{"location":"keri-protocol/#duplicity-is-detectable-not-preventable","title":"Duplicity is Detectable, Not Preventable","text":"<p>KERI does not claim to prevent duplicity \u2014 it claims to make duplicity detectable and attributable. Once a controller is caught equivocating, their identifier is effectively poisoned: no rational verifier will trust them.</p> <p>This is analogous to Bitcoin's security model for double-spend: the network doesn't prevent you from trying, but it makes the attempt detectable and economically irrational.</p>"},{"location":"keri-protocol/#the-keri-security-assumptions","title":"The KERI Security Assumptions","text":"<p>KERI's security reduces to two assumptions:</p> <ol> <li>Cryptographic hardness: hash functions and digital signatures are secure (standard assumption).</li> <li>Witness honesty threshold: a sufficient number of witnesses are not colluding with an adversary. With a well-chosen diverse witness set, this is a very mild assumption.</li> </ol> <p>Notably, KERI does not assume Byzantine fault tolerance, economic incentives (no token required), or trusted third parties.</p>"},{"location":"keri-protocol/#9-trust-hierarchy-without-a-ledger","title":"9. Trust Hierarchy Without a Ledger","text":"<p>Traditional PKI requires a root CA. Blockchain DIDs require a canonical ledger state. KERI requires neither.</p> <p>Instead, KERI uses a TERD (Trust Extending Root of Discovery) approach: Alice gives Bob her AID out-of-band; Bob resolves Alice's KEL from Alice's witnesses; Bob's watcher monitors for duplicity; all subsequent verifications are purely cryptographic.</p> <p>The root of trust is the inception event and the key ceremony that produced it.</p> <p>End-to-end trust flow:</p> <pre><code>flowchart LR\n    subgraph Bootstrap[\"Out-of-Band Bootstrap\"]\n        OOB[\"Alice shares AID\\nwith Bob\\nQR / NFC / URL\"]\n    end\n\n    subgraph Alice[\"Alice - Controller\"]\n        AKEL[\"Alice's KEL\\nicp to ixn to rot\"]\n        AWit[\"Alice's Witnesses\\nW1, W2, W3\"]\n        AKEL --&gt; AWit\n    end\n\n    subgraph Bob[\"Bob - Verifier\"]\n        BWat[\"Bob's Watchers\"]\n        BVerify[\"1. Fetch KEL from witnesses\\n2. Validate hash chain\\n3. Check pre-rotation\\n4. Verify all signatures\\n5. No duplicity detected\"]\n        TRUST[\"Trust established\\npurely cryptographically\"]\n        BWat --&gt; BVerify --&gt; TRUST\n    end\n\n    OOB --&gt;|\"AID prefix\"| Bob\n    AWit --&gt;|\"KEL + receipts\"| BWat</code></pre>"},{"location":"keri-protocol/#10-keri-vs-other-did-methods","title":"10. KERI vs Other DID Methods","text":"Feature did:key did:ethr / did:ion did:keri Self-certifying Yes Partial Yes Key rotation No Yes (on-chain) Yes (off-chain) Pre-rotation No No Yes Ledger dependency No Yes (hard) No Censorship resistance N/A Depends on chain Yes Multisig No Partial Yes (native) Delegation No No Yes (cryptographic) Verifiable offline Yes No Yes Long-term key management No Partial Yes Infrastructure cost None High (gas) Low (witnesses) <pre><code>quadrantChart\n    title Identity Architectures: Decentralization vs Key Management Power\n    x-axis Centralized --&gt; Fully Decentralized\n    y-axis Basic Key Mgmt --&gt; Advanced Key Mgmt\n    quadrant-1 Ideal\n    quadrant-2 Powerful but Centralized\n    quadrant-3 Simple but Limited\n    quadrant-4 Decentralized but Limited\n    Traditional PKI: [0.10, 0.30]\n    did-web: [0.20, 0.25]\n    did-key: [0.85, 0.10]\n    did-ethr: [0.60, 0.50]\n    did-ion: [0.65, 0.55]\n    did-peer: [0.80, 0.20]\n    KERI: [0.88, 0.92]</code></pre>"},{"location":"keri-protocol/#11-acdc-authentic-chained-data-containers","title":"11. ACDC: Authentic Chained Data Containers","text":"<p>KERI provides the key management layer. ACDC (Authentic Chained Data Containers) is the credential layer built on top.</p> <p>An ACDC is a signed, self-describing data container: issued by an AID, issued to an AID, optionally chained to parent credentials, and revocable via a Transaction Event Log (TEL) anchored into the issuer's KEL.</p> <p>ACDCs can be public (fully disclosed), private (selectively disclosed via Graduated Disclosure), targeted (to a specific holder), or untargeted (bearer credentials).</p> <pre><code>flowchart TD\n    subgraph KERI[\"KERI Layer\"]\n        AID_I[\"Issuer AID + KEL\"]\n        AID_H[\"Holder AID + KEL\"]\n    end\n\n    subgraph TEL[\"Transaction Event Log\"]\n        ISS[\"iss \u2014 issuance\"]\n        REV[\"rev \u2014 revocation\"]\n    end\n\n    subgraph ACDC[\"ACDC Credential\"]\n        CRED[\"Issuer AID\\nHolder AID\\nClaims + Schema\\nSAID\\nSigned by Issuer\"]\n    end\n\n    subgraph Verify[\"Verification\"]\n        V1[\"1. Verify issuer signature vs KEL\"]\n        V2[\"2. Check TEL: revoked?\"]\n        V3[\"3. Verify holder controls AID\"]\n        OK[\"Credential Valid\"]\n    end\n\n    AID_I --&gt; CRED\n    AID_I --&gt; TEL\n    CRED --&gt; AID_H\n    CRED --&gt; V1\n    TEL --&gt; V2\n    AID_H --&gt; V3\n    V1 --&gt; OK\n    V2 --&gt; OK\n    V3 --&gt; OK</code></pre> <p>The combination of KERI + ACDC provides a complete verifiable credential ecosystem without any external registry or token economy.</p>"},{"location":"keri-protocol/#12-implementation-landscape","title":"12. Implementation Landscape","text":""},{"location":"keri-protocol/#reference-implementations","title":"Reference Implementations","text":"Implementation Language Maintainer keripy Python WebOfTrust / GLEIF keriox Rust WebOfTrust signify-ts TypeScript WebOfTrust cesr-one Python WebOfTrust"},{"location":"keri-protocol/#cesr-composable-event-streaming-representation","title":"CESR: Composable Event Streaming Representation","text":"<p>All KERI events are encoded in CESR (Composable Event Streaming Representation), a novel encoding designed by Sam Smith that is self-framing, both text-mode (Base64url) and binary-mode compatible, and composable. CESR replaces the need for DER/ASN.1, CBOR, or JSON-LD in the core protocol layer.</p>"},{"location":"keri-protocol/#gleif-and-vlei","title":"GLEIF and vLEI","text":"<p>The Global Legal Entity Identifier Foundation (GLEIF) is deploying KERI as the foundation for the vLEI (verifiable Legal Entity Identifier) ecosystem \u2014 a globally standardized identity credential system for legal entities. This is the most significant real-world deployment of KERI to date.</p>"},{"location":"keri-protocol/#13-strengths-and-tradeoffs","title":"13. Strengths and Tradeoffs","text":""},{"location":"keri-protocol/#strengths","title":"Strengths","text":"<ul> <li>No ledger dependency: portable, censorship-resistant, zero infrastructure lock-in.</li> <li>Pre-rotation: strongest key compromise recovery of any mainstream identity protocol.</li> <li>Cryptographic delegation: enterprise-grade key hierarchy without central registry.</li> <li>End-verifiability: any party can verify the full history with only the KEL and public keys.</li> <li>Quantum resistance path: can upgrade hash functions and signature schemes via rotation; post-quantum algorithms are supported.</li> <li>No token economy: no gas, no staking, no blockchain fees.</li> </ul>"},{"location":"keri-protocol/#tradeoffs-and-challenges","title":"Tradeoffs and Challenges","text":"<ul> <li>Complexity: KERI's security model, especially duplicity detection and the watcher network, is significantly more complex than simple PKI or did:key.</li> <li>Witness infrastructure: you need a witness network for availability and consistency \u2014 this is simpler than a blockchain but is still infrastructure to operate.</li> <li>First-seen ordering is probabilistic: KERI doesn't provide global total ordering (by design), which means subtle equivocation attacks are possible in adversarial settings, though they are detectable.</li> <li>Discovery: there is no single canonical registry for \"look up an AID\" \u2014 discovery is handled by out-of-band means or secondary indexers.</li> <li>Ecosystem maturity: as of 2025, KERI tooling is maturing but not yet as polished as did:web or did:ethr for basic use cases.</li> <li>Learning curve: the mental model (KEL, pre-rotation, witnesses vs watchers, CESR encoding) is unfamiliar to most developers.</li> </ul>"},{"location":"keri-protocol/#14-quick-reference-glossary","title":"14. Quick Reference Glossary","text":"Term Definition AID Autonomic Identifier \u2014 a self-certifying identifier derived from key material SAID Self-Addressing IDentifier \u2014 an identifier that is the digest of the data it identifies KEL Key Event Log \u2014 append-only, hash-chained log of all key events for an AID KERL Key Event Receipt Log \u2014 the KEL plus all witness receipts icp Inception event \u2014 creates an AID rot Rotation event \u2014 rotates the key set ixn Interaction event \u2014 anchors data without changing keys dip/drt Delegated inception/rotation events Pre-rotation Committing to the next key's digest before it is needed Witness A service that receipts key events; chosen by the controller Watcher A service that monitors KELs for duplicity; chosen by the verifier CESR Composable Event Streaming Representation \u2014 KERI's encoding format ACDC Authentic Chained Data Container \u2014 KERI's credential format TEL Transaction Event Log \u2014 anchored log for credential issuance/revocation Duplicity Presenting conflicting versions of a KEL to different parties First Seen The ordering in which a witness/watcher first receives an event vLEI Verifiable Legal Entity Identifier \u2014 GLEIF's KERI-based credential system TERD Trust Extending Root of Discovery \u2014 KERI's trust bootstrap model"},{"location":"keri-protocol/#further-reading","title":"Further Reading","text":"<ul> <li>KERI White Paper \u2014 Samuel M. Smith, 2019</li> <li>WebOfTrust GitHub Organization \u2014 reference implementations and specs</li> <li>KERI Docs \u2014 community documentation hub</li> <li>GLEIF vLEI Ecosystem \u2014 real-world deployment</li> <li>CESR Spec \u2014 encoding specification</li> <li>ACDC Spec \u2014 credential layer specification</li> </ul> <p>Document prepared: February 2026</p>"}]}